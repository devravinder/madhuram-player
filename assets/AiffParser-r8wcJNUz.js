import{q as e}from"./index-DXzd5qjx.js";import{D as t,E as n,S as r,_ as i,o as a,s as o,t as s,v as c}from"./BasicParser-CQ20OyPe.js";import{i as l,n as u}from"./core-SrxPbndD.js";import"./Util-DQbBdhOk.js";import"./ID3v2Token-CZhNPdau.js";import{i as d}from"./APEv2Parser-C0ORq7CU.js";import"./ID3v1Parser-lcVJ6Kic.js";import{t as f}from"./ID3v2Parser-BKgsxlF0.js";var p=e(o(),1);const m={NONE:`not compressed	PCM	Apple Computer`,sowt:`PCM (byte swapped)`,fl32:`32-bit floating point IEEE 32-bit float`,fl64:`64-bit floating point IEEE 64-bit float	Apple Computer`,alaw:`ALaw 2:1	8-bit ITU-T G.711 A-law`,ulaw:`µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer`,ULAW:`CCITT G.711 u-law 8-bit ITU-T G.711 µ-law`,ALAW:`CCITT G.711 A-law 8-bit ITU-T G.711 A-law`,FL32:`Float 32	IEEE 32-bit float `};var h=class extends a(`AIFF`){},g=class{constructor(e,t){this.isAifc=t;let n=t?22:18;if(e.chunkSize<n)throw new h(`COMMON CHUNK size should always be at least ${n}`);this.len=e.chunkSize}get(e,t){let a=c.get(e,t+8)-16398,o=c.get(e,t+8+2),s={numChannels:c.get(e,t),numSampleFrames:r.get(e,t+2),sampleSize:c.get(e,t+6),sampleRate:a<0?o>>Math.abs(a):o<<a};if(this.isAifc){if(s.compressionType=d.get(e,t+18),this.len>22){let r=n.get(e,t+22);if(r>0){let n=(r+1)%2;if(23+r+n===this.len)s.compressionName=new i(r,`latin1`).get(e,t+23);else throw new h(`Illegal pstring length`)}else s.compressionName=void 0}}else s.compressionName=`PCM`;return s}};const _={len:8,get:(e,t)=>({chunkID:d.get(e,t),chunkSize:Number(BigInt(r.get(e,t+4)))})};var v=(0,p.default)(`music-metadata:parser:aiff`),y=class extends s{constructor(){super(...arguments),this.isCompressed=null}async parse(){if((await this.tokenizer.readToken(_)).chunkID!==`FORM`)throw new h(`Invalid Chunk-ID, expected 'FORM'`);let e=await this.tokenizer.readToken(d);switch(e){case`AIFF`:this.metadata.setFormat(`container`,e),this.isCompressed=!1;break;case`AIFC`:this.metadata.setFormat(`container`,`AIFF-C`),this.isCompressed=!0;break;default:throw new h(`Unsupported AIFF type: ${e}`)}this.metadata.setFormat(`lossless`,!this.isCompressed),this.metadata.setAudioOnly();try{for(;!this.tokenizer.fileInfo.size||this.tokenizer.fileInfo.size-this.tokenizer.position>=_.len;){v(`Reading AIFF chunk at offset=${this.tokenizer.position}`);let e=await this.tokenizer.readToken(_),t=2*Math.round(e.chunkSize/2),n=await this.readData(e);await this.tokenizer.ignore(t-n)}}catch(e){if(e instanceof l)v(`End-of-stream`);else throw e}}async readData(e){switch(e.chunkID){case`COMM`:{if(this.isCompressed===null)throw new h(`Failed to parse AIFF.COMM chunk when compression type is unknown`);let t=await this.tokenizer.readToken(new g(e,this.isCompressed));return this.metadata.setFormat(`bitsPerSample`,t.sampleSize),this.metadata.setFormat(`sampleRate`,t.sampleRate),this.metadata.setFormat(`numberOfChannels`,t.numChannels),this.metadata.setFormat(`numberOfSamples`,t.numSampleFrames),this.metadata.setFormat(`duration`,t.numSampleFrames/t.sampleRate),(t.compressionName||t.compressionType)&&this.metadata.setFormat(`codec`,t.compressionName??m[t.compressionType]),e.chunkSize}case`ID3 `:{let n=u(await this.tokenizer.readToken(new t(e.chunkSize)));return await new f().parse(this.metadata,n,this.options),e.chunkSize}case`SSND`:return this.metadata.format.duration&&this.metadata.setFormat(`bitrate`,8*e.chunkSize/this.metadata.format.duration),0;case`NAME`:case`AUTH`:case`(c) `:case`ANNO`:return this.readTextChunk(e);default:return v(`Ignore chunk id=${e.chunkID}, size=${e.chunkSize}`),0}}async readTextChunk(e){let t=(await this.tokenizer.readToken(new i(e.chunkSize,`ascii`))).split(`\0`).map(e=>e.trim()).filter(e=>e?.length);return await Promise.all(t.map(t=>this.metadata.addTag(`AIFF`,e.chunkID,t))),e.chunkSize}};export{y as AIFFParser};