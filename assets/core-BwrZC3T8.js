var e=class extends Error{constructor(){super(`End-Of-Stream`),this.name=`EndOfStreamError`}},t=class extends Error{constructor(e=`The operation was aborted`){super(e),this.name=`AbortError`}},n=class{constructor(){this.endOfStream=!1,this.interrupted=!1,this.peekQueue=[]}async peek(e,t=!1){let n=await this.read(e,t);return this.peekQueue.push(e.subarray(0,n)),n}async read(t,n=!1){if(t.length===0)return 0;let r=this.readFromPeekBuffer(t);if(this.endOfStream||(r+=await this.readRemainderFromStream(t.subarray(r),n)),r===0&&!n)throw new e;return r}readFromPeekBuffer(e){let t=e.length,n=0;for(;this.peekQueue.length>0&&t>0;){let r=this.peekQueue.pop();if(!r)throw Error(`peekData should be defined`);let i=Math.min(r.length,t);e.set(r.subarray(0,i),n),n+=i,t-=i,i<r.length&&this.peekQueue.push(r.subarray(i))}return n}async readRemainderFromStream(n,r){let i=0;for(;i<n.length&&!this.endOfStream;){if(this.interrupted)throw new t;let e=await this.readFromStream(n.subarray(i),r);if(e===0)break;i+=e}if(!r&&i<n.length)throw new e;return i}},r=class extends n{constructor(e){super(),this.reader=e}async abort(){return this.close()}async close(){this.reader.releaseLock()}},i=class extends r{async readFromStream(e,t){if(e.length===0)return 0;let n=await this.reader.read(new Uint8Array(e.length),{min:t?void 0:e.length});return n.done&&(this.endOfStream=n.done),n.value?(e.set(n.value),n.value.length):0}},a=class extends n{constructor(e){super(),this.reader=e,this.buffer=null}writeChunk(e,t){let n=Math.min(t.length,e.length);return e.set(t.subarray(0,n)),n<t.length?this.buffer=t.subarray(n):this.buffer=null,n}async readFromStream(t,n){if(t.length===0)return 0;let r=0;for(this.buffer&&(r+=this.writeChunk(t,this.buffer));r<t.length&&!this.endOfStream;){let e=await this.reader.read();if(e.done){this.endOfStream=!0;break}e.value&&(r+=this.writeChunk(t.subarray(r),e.value))}if(!n&&r===0&&this.endOfStream)throw new e;return r}abort(){return this.interrupted=!0,this.reader.cancel()}async close(){await this.abort(),this.reader.releaseLock()}};function o(e){try{let t=e.getReader({mode:`byob`});return t instanceof ReadableStreamDefaultReader?new a(t):new i(t)}catch(t){if(t instanceof TypeError)return new a(e.getReader());throw t}}var s=class{constructor(e){this.numBuffer=new Uint8Array(8),this.position=0,this.onClose=e?.onClose,e?.abortSignal&&e.abortSignal.addEventListener(`abort`,()=>{this.abort()})}async readToken(t,n=this.position){let r=new Uint8Array(t.len);if(await this.readBuffer(r,{position:n})<t.len)throw new e;return t.get(r,0)}async peekToken(t,n=this.position){let r=new Uint8Array(t.len);if(await this.peekBuffer(r,{position:n})<t.len)throw new e;return t.get(r,0)}async readNumber(t){if(await this.readBuffer(this.numBuffer,{length:t.len})<t.len)throw new e;return t.get(this.numBuffer,0)}async peekNumber(t){if(await this.peekBuffer(this.numBuffer,{length:t.len})<t.len)throw new e;return t.get(this.numBuffer,0)}async ignore(e){if(this.fileInfo.size!==void 0){let t=this.fileInfo.size-this.position;if(e>t)return this.position+=t,t}return this.position+=e,e}async close(){await this.abort(),await this.onClose?.()}normalizeOptions(e,t){if(!this.supportsRandomAccess()&&t&&t.position!==void 0&&t.position<this.position)throw Error("`options.position` must be equal or greater than `tokenizer.position`");return{mayBeLess:!1,offset:0,length:e.length,position:this.position,...t}}abort(){return Promise.resolve()}},c=256e3,l=class extends s{constructor(e,t){super(t),this.streamReader=e,this.fileInfo=t?.fileInfo??{}}async readBuffer(t,n){let r=this.normalizeOptions(t,n),i=r.position-this.position;if(i>0)return await this.ignore(i),this.readBuffer(t,n);if(i<0)throw Error("`options.position` must be equal or greater than `tokenizer.position`");if(r.length===0)return 0;let a=await this.streamReader.read(t.subarray(0,r.length),r.mayBeLess);if(this.position+=a,(!n||!n.mayBeLess)&&a<r.length)throw new e;return a}async peekBuffer(t,n){let r=this.normalizeOptions(t,n),i=0;if(r.position){let e=r.position-this.position;if(e>0){let n=new Uint8Array(r.length+e);return i=await this.peekBuffer(n,{mayBeLess:r.mayBeLess}),t.set(n.subarray(e)),i-e}if(e<0)throw Error(`Cannot peek from a negative offset in a stream`)}if(r.length>0){try{i=await this.streamReader.peek(t.subarray(0,r.length),r.mayBeLess)}catch(t){if(n?.mayBeLess&&t instanceof e)return 0;throw t}if(!r.mayBeLess&&i<r.length)throw new e}return i}async ignore(e){let t=Math.min(c,e),n=new Uint8Array(t),r=0;for(;r<e;){let i=e-r,a=await this.readBuffer(n,{length:Math.min(t,i)});if(a<0)return a;r+=a}return r}abort(){return this.streamReader.abort()}async close(){return this.streamReader.close()}supportsRandomAccess(){return!1}},u=class extends s{constructor(e,t){super(t),this.uint8Array=e,this.fileInfo={...t?.fileInfo??{},size:e.length}}async readBuffer(e,t){t?.position&&(this.position=t.position);let n=await this.peekBuffer(e,t);return this.position+=n,n}async peekBuffer(t,n){let r=this.normalizeOptions(t,n),i=Math.min(this.uint8Array.length-r.position,r.length);if(!r.mayBeLess&&i<r.length)throw new e;return t.set(this.uint8Array.subarray(r.position,r.position+i)),i}close(){return super.close()}supportsRandomAccess(){return!0}setPosition(e){this.position=e}},d=class extends s{constructor(e,t){super(t),this.blob=e,this.fileInfo={...t?.fileInfo??{},size:e.size,mimeType:e.type}}async readBuffer(e,t){t?.position&&(this.position=t.position);let n=await this.peekBuffer(e,t);return this.position+=n,n}async peekBuffer(t,n){let r=this.normalizeOptions(t,n),i=Math.min(this.blob.size-r.position,r.length);if(!r.mayBeLess&&i<r.length)throw new e;let a=await this.blob.slice(r.position,r.position+i).arrayBuffer();return t.set(new Uint8Array(a)),i}close(){return super.close()}supportsRandomAccess(){return!0}setPosition(e){this.position=e}};function f(e,t){let n=o(e),r=t??{},i=r.onClose;return r.onClose=async()=>{if(await n.close(),i)return i()},new l(n,r)}function p(e,t){return new u(e,t)}function m(e,t){return new d(e,t)}export{e as i,p as n,f as r,m as t};